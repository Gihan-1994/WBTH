generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                          String                 @id @default(uuid())
  name                        String
  email                       String                 @unique
  password_hash               String
  contact_no                  String?
  role                        UserRole               @default(tourist)
  created_at                  DateTime               @default(now()) @map("created_at")
  email_notifications_enabled Boolean                @default(true)
  accommodationProvider       AccommodationProvider?
  admin                       Admin?
  bookings                    Booking[]
  guide                       Guide?
  notifications               Notification[]
  paymentsReceived            Payment[]              @relation("ReceiverPayments")
  paymentsSent                Payment[]              @relation("SenderPayments")
  ratings                     Rating[]
  tourist                     Tourist?

  @@map("users")
}

model Tourist {
  user_id         String    @id
  country         String?
  dob             DateTime?
  profile_picture String?
  user            User      @relation(fields: [user_id], references: [id])

  @@map("tourists")
}

model Guide {
  user_id         String    @id
  experience      String[]
  languages       String[]
  expertise       String[]
  rating          Float?
  account_no      String?
  price           Float?
  availability    Boolean   @default(true)
  profile_picture String?
  city            String?
  province        String?
  gender          String?
  booking_price   Float?
  bookings        Booking[]
  user            User      @relation(fields: [user_id], references: [id])

  @@map("guides")
}

model AccommodationProvider {
  user_id        String          @id
  provider_id    String          @unique @default(uuid())
  company_name   String
  logo           String?
  location       String?
  user           User            @relation(fields: [user_id], references: [id])
  accommodations Accommodation[]

  @@map("accommodation_providers")
}

model Accommodation {
  id                String                @id @default(uuid())
  provider_id       String
  name              String
  type              String[]
  amenities         String[]
  rating            Float?
  account_no        String?
  budget            String[]
  district          String
  price_range_min   Float?
  price_range_max   Float?
  province          String?
  interests         String[]
  group_size        Int?
  num_booking_dates Int?
  prior_bookings    Int?
  images            String[]
  travel_style      String[]
  location          String?
  booking_price     Float?
  provider          AccommodationProvider @relation(fields: [provider_id], references: [provider_id])
  bookings          Booking[]

  @@map("accommodations")
}

model Booking {
  id               String         @id @default(uuid())
  user_id          String
  type             BookingType
  start_date       DateTime       @map("start_date")
  end_date         DateTime       @map("end_date")
  location         String?
  price            Float
  status           BookingStatus  @default(pending)
  description      String[]
  accommodation_id String?
  guide_id         String?
  accommodation    Accommodation? @relation(fields: [accommodation_id], references: [id])
  guide            Guide?         @relation(fields: [guide_id], references: [user_id])
  user             User           @relation(fields: [user_id], references: [id])
  notifications    Notification[]
  payments         Payment[]
  rating           Rating?

  @@map("bookings")
}

model Rating {
  id         String   @id @default(uuid())
  rating     Int
  booking_id String   @unique
  comment    String?
  created_at DateTime @default(now())
  user_id    String
  booking    Booking  @relation(fields: [booking_id], references: [id])
  user       User     @relation(fields: [user_id], references: [id])

  @@map("ratings")
}

model Event {
  id          String   @id @default(uuid())
  category    String
  date        DateTime
  location    String
  description String[]
  eventImages String[]
  title       String   @default("Untitled Event")

  @@map("events")
}

model Payment {
  id                       String        @id @default(uuid())
  receiver_id              String
  sender_id                String
  booking_id               String
  amount                   Float
  stripe_payment_intent_id String?
  status                   PaymentStatus @default(pending)
  booking                  Booking       @relation(fields: [booking_id], references: [id])
  receiver                 User          @relation("ReceiverPayments", fields: [receiver_id], references: [id])
  sender                   User          @relation("SenderPayments", fields: [sender_id], references: [id])

  @@map("payments")
}

model Notification {
  id         String           @id @default(uuid())
  user_id    String
  message    String
  created_at DateTime         @default(now()) @map("created_at")
  booking_id String?
  is_read    Boolean          @default(false)
  metadata   Json?
  type       NotificationType
  booking    Booking?         @relation(fields: [booking_id], references: [id])
  user       User             @relation(fields: [user_id], references: [id])

  @@index([user_id, is_read])
  @@map("notifications")
}

model Admin {
  id      String @id @default(uuid())
  user_id String @unique
  user    User   @relation(fields: [user_id], references: [id])

  @@map("admins")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

enum UserRole {
  tourist
  guide
  accommodation_provider
  admin
}

enum BookingType {
  accommodation
  guide
}

enum BookingStatus {
  pending
  confirmed
  cancelled
}

enum NotificationType {
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  BOOKING_UPDATED
  PAYMENT_RECEIVED
  PAYMENT_SENT
  ADMIN_MESSAGE
}

enum PaymentStatus {
  pending
  authorized
  captured
  cancelled
  failed
}
